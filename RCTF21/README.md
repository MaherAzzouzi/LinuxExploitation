### unistruct

Wrong edit implementation on vector (data type 4), it will decrement the pointer by 4 when appending to the vector (giving 0 to append or in place):
```*p = local_20 + -0x4;```

Then there is the possibility to dereference it as a pointer and write an integer there:
```
puVar6 = (uint *)deref_rdi(&p);
*puVar6 = uVar1;
```
That could lead to oob backward write and read.
Leak heap then tcache dup to get a chunk at the array holding our objects of all types.
Fake a basic_string class to leak libc.
Fake a basic_string to __free_hook and change it to system.

### ezheap

ezheap was a type confusion, the bug was to create a chunk of type ByteArray each element has 1 byte, and access it as Uint32Array.
In the exploit I created an array of bytes of size 0xc and accessing it as Int gave me heap leaks (which are mmaped we can get libc base from that leak), and I had oob write too.
I leaked environ to reveal a stack pointer, then write a ROP chain in the stack.
The allocations are randomized that's why it needs several tries

### sharing

This was an easy challenge, I used only the arb decrement by 2.
For leaking libc it was easy just provide a big chunk to (hint) it will free some unsorted bin chunks, and then you can get it in alloc and then show.
I used arb decrement by 2 to make the second pointer close to __free_hook (this is the start of libc bss):
```0x7f16e2cd7000:	0x00000000003eab80	0x00007f16e34a19f0```

0x00000000003eab80 will act as the size of that pointer, then you can just send b"\x00"*0x108 + p64(system)

Now to get arb code execution we need to call free, and we can do that by providing "/bin/sh\x00"*0x50 to hint, at the end it will free it and we will get a shell.

This exploit is working like 1/2 times, depending if the bytes provided by ASLR are even or not.
